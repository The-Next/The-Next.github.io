<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程佩的博客</title>
  
  <subtitle>没有银弹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-05-21T14:37:35.420Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>程佩</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2020/03/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/31/动态规划/</id>
    <published>2020-03-31T08:56:25.000Z</published>
    <updated>2022-05-21T14:37:35.420Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;中间因为各种破事，好久没有写了，趁着这次开学上算法课，把学了好久的&lt;strong&gt;动态规划&lt;/strong&gt;算法总结一下。&lt;br&gt;&amp;emsp;&amp;emsp;说动态规划之前先说一下&lt;strong&gt;贪心算法&lt;/strong&gt;。比如说给你一堆价值为1、2、3、4、5的物品若干（物品可以装&lt;strong&gt;一半或者某一个分数&lt;/strong&gt;），让你取一定价值的物品，使得取得的物品数量最少，正常的思路就是先拿价值为5的，拿完了之后再拿价值为4的，依此类推，直到拿够数量为止，这样拿到的物品总价值也就最大。这种策略就是&lt;strong&gt;贪心&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-支持向量机</title>
    <link href="http://yoursite.com/2019/11/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>http://yoursite.com/2019/11/04/机器学习-支持向量机/</id>
    <published>2019-11-04T11:28:11.000Z</published>
    <updated>2019-11-14T13:39:27.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;支持向量机&quot;&gt;&lt;a href=&quot;#支持向量机&quot; class=&quot;headerlink&quot; title=&quot;支持向量机&quot;&gt;&lt;/a&gt;支持向量机&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这里有一个非常强大的算法，它在工业和学术界应用的非常广泛，它叫做&lt;strong&gt;支持向量机&lt;/strong&gt;，与逻辑回归和神经网络相比，&lt;strong&gt;SVM&lt;/strong&gt;（支持向量机）可以在学习复杂的非线性方程时提供更强大和更清晰的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-神经网络参数的反向传播算法</title>
    <link href="http://yoursite.com/2019/10/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/15/机器学习-神经网络参数的反向传播算法/</id>
    <published>2019-10-15T02:47:38.000Z</published>
    <updated>2019-10-31T13:35:36.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神经网络参数的反向传播算法&quot;&gt;&lt;a href=&quot;#神经网络参数的反向传播算法&quot; class=&quot;headerlink&quot; title=&quot;神经网络参数的反向传播算法&quot;&gt;&lt;/a&gt;神经网络参数的反向传播算法&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这里总结一个算法，能够给有给定的训练集的时候给神经网络训练参数。和之前一样，先从代价函数说起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-神经网络学习</title>
    <link href="http://yoursite.com/2019/09/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/09/20/机器学习-神经网络学习/</id>
    <published>2019-09-20T07:37:32.000Z</published>
    <updated>2019-09-22T12:23:20.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神经网络学习&quot;&gt;&lt;a href=&quot;#神经网络学习&quot; class=&quot;headerlink&quot; title=&quot;神经网络学习&quot;&gt;&lt;/a&gt;神经网络学习&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在学习神经网络之前，这个名词经常在各种场合被提起，我对他的认知也只限于直到他跟大脑有关，至于有什么关系我还真不清楚，这一部分我也是花了不少时间去理解，从神经元结构开始，到最简单到一个模型，初步明白了它的概念以及他所解决的在线性回归和逻辑回归中的痛点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-正则化</title>
    <link href="http://yoursite.com/2019/09/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/11/机器学习-正则化/</id>
    <published>2019-09-11T12:32:32.000Z</published>
    <updated>2019-11-05T13:38:08.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;正则化&quot;&gt;&lt;a href=&quot;#正则化&quot; class=&quot;headerlink&quot; title=&quot;正则化&quot;&gt;&lt;/a&gt;正则化&lt;/h1&gt;&lt;h2 id=&quot;过拟合问题&quot;&gt;&lt;a href=&quot;#过拟合问题&quot; class=&quot;headerlink&quot; title=&quot;过拟合问题&quot;&gt;&lt;/a&gt;过拟合问题&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在我们进行线性拟合的过程中，有时候可能拟合的效果比较差，比如说用一个一次函数去拟合一如下图所示的样本，那么我们可以看出该算法并没有很好的拟合训练集，我们将它称之为“欠拟合”，也说他是“高偏差”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-Logistic回归</title>
    <link href="http://yoursite.com/2019/07/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Logistic%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2019/07/24/机器学习-Logistic回归/</id>
    <published>2019-07-24T01:07:24.000Z</published>
    <updated>2019-09-11T12:51:46.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Logistic回归&quot;&gt;&lt;a href=&quot;#Logistic回归&quot; class=&quot;headerlink&quot; title=&quot;Logistic回归&quot;&gt;&lt;/a&gt;Logistic回归&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;虽然这个算法叫做&lt;strong&gt;Logistic回归&lt;/strong&gt;，但是他却是一个分类算法。分类算法通常是离散的，它通常只有两个值，0或1，也叫负类或者正类，也有更多的分类，但是这里只考虑两种情况的分类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-多变量线性回归</title>
    <link href="http://yoursite.com/2019/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2019/07/22/机器学习-多变量线性回归/</id>
    <published>2019-07-22T07:05:20.000Z</published>
    <updated>2019-09-11T12:51:43.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多变量线性回归&quot;&gt;&lt;a href=&quot;#多变量线性回归&quot; class=&quot;headerlink&quot; title=&quot;多变量线性回归&quot;&gt;&lt;/a&gt;多变量线性回归&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在学过了一元线性回归之后，再来看一下另外一种可以适用于多个变量的模型————多元线性回归。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-单变量线性回归</title>
    <link href="http://yoursite.com/2019/07/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2019/07/15/机器学习-单变量线性回归/</id>
    <published>2019-07-15T05:24:58.000Z</published>
    <updated>2022-05-21T14:45:44.699Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单变量线性回归&quot;&gt;&lt;a href=&quot;#单变量线性回归&quot; class=&quot;headerlink&quot; title=&quot;单变量线性回归&quot;&gt;&lt;/a&gt;单变量线性回归&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;机器学习第一坑，跟着网易云课堂上吴恩达的机器学习课程学习，纯英文的，但是有字幕，语速什么的都非常不错。为这个课程写博客的目的只有一个，就是为了记录和总结，不然仅仅是听课的话，听完过一段就忘了，记录下来方面以后复习使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2019/06/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/06/18/排序算法/</id>
    <published>2019-06-18T14:21:33.000Z</published>
    <updated>2019-07-15T05:23:16.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;输入：一个n个数的序列 a&lt;sub&gt;1&lt;/sub&gt;，a&lt;sub&gt;2&lt;/sub&gt;……a&lt;sub&gt;n&lt;/sub&gt;&lt;br&gt;输出输入序列的一个排列a&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;‘&lt;/sup&gt;，a&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;‘&lt;/sup&gt;……&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;‘&lt;/sup&gt;，使得a&lt;sub&gt;1&lt;/sub&gt;&lt;sup&gt;‘&lt;/sup&gt;&amp;lt;=a&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;‘&lt;/sup&gt;&amp;lt;=……&amp;lt;=a&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;‘&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;简而言之，排序就是将一组对象按照某一种逻辑顺序重新排列的过程，这是一个很古老的算法，同时在各个领域都起到了非常重要的作用，所以在这里对排序算法做一次总结。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>禹州实训-宠物医院-后端</title>
    <link href="http://yoursite.com/2019/05/22/%E7%A6%B9%E5%B7%9E%E5%AE%9E%E8%AE%AD-%E5%AE%A0%E7%89%A9%E5%8C%BB%E9%99%A2-%E5%90%8E%E7%AB%AF/"/>
    <id>http://yoursite.com/2019/05/22/禹州实训-宠物医院-后端/</id>
    <published>2019-05-22T08:06:34.000Z</published>
    <updated>2019-07-06T03:01:19.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;禹州实训-宠物医院-后端&quot;&gt;&lt;a href=&quot;#禹州实训-宠物医院-后端&quot; class=&quot;headerlink&quot; title=&quot;禹州实训-宠物医院(后端)&quot;&gt;&lt;/a&gt;禹州实训-宠物医院(后端)&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;今年实训项目是一个只有增删改查的管理系统，没啥难度，后端基本都是体力活，所以&lt;code&gt;SpringBoot&lt;/code&gt;加&lt;code&gt;Spring-data-jpa&lt;/code&gt;写这个最爽了，前端打算使用&lt;code&gt;Angular&lt;/code&gt;和&lt;code&gt;Angular Material&lt;/code&gt;构建一下(不想用jsp那种破烂了)，前端东西有点多，所以分开记录(前端太无聊，鸽了)。so，这就是一个前后端分离的项目了，后端目前就只有一个写接口的任务。&lt;/p&gt;
    
    </summary>
    
      <category term="禹州实训" scheme="http://yoursite.com/categories/%E7%A6%B9%E5%B7%9E%E5%AE%9E%E8%AE%AD/"/>
    
    
      <category term="禹州实训" scheme="http://yoursite.com/tags/%E7%A6%B9%E5%B7%9E%E5%AE%9E%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker部署静态网页</title>
    <link href="http://yoursite.com/2019/04/28/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2019/04/28/使用docker部署静态网页/</id>
    <published>2019-04-28T07:50:46.000Z</published>
    <updated>2022-05-21T16:30:18.837Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用docker部署静态网页&quot;&gt;&lt;a href=&quot;#使用docker部署静态网页&quot; class=&quot;headerlink&quot; title=&quot;使用docker部署静态网页&quot;&gt;&lt;/a&gt;使用docker部署静态网页&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Docker是一个使用Go语言开发的容器引擎，可以将应用以及依赖环境打包进容器中，容器是可以移植到任何操作系统上(一般是Linux)，容器与容器之间是完全隔离的，容器之间不会有任何接口。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Django-rest-framework开发总结-项目搭建</title>
    <link href="http://yoursite.com/2019/02/28/Django-rest-framework%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/02/28/Django-rest-framework开发总结-项目搭建/</id>
    <published>2019-02-28T12:08:48.000Z</published>
    <updated>2019-03-08T12:04:09.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Django-rest-framework开发总结-项目搭建&quot;&gt;&lt;a href=&quot;#Django-rest-framework开发总结-项目搭建&quot; class=&quot;headerlink&quot; title=&quot;Django-rest-framework开发总结-项目搭建&quot;&gt;&lt;/a&gt;Django-rest-framework开发总结-项目搭建&lt;/h1&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;我第一次开发web应用用的就是Django，甚至比最熟悉的Java还早，目前开发了两个应用，一个报名系统，一个考试系统，不敢说对这个框架很熟悉吧，但是也是有一些了解的，毕竟踩过不少坑，一个bug改三天的事也经常干，但是自从开了博客以来却没有总结过任何关于Django的文章，借着这次开发的机会总结一下，就当是做笔记了。这一回开发的并不是普通的Django应用，而是仅仅提供rest风格数据接口的服务接口的应用，这一过程中除了后台展示界面以外，我并没有参加关于任何前端的开发，目前来讲这也是一种国际上的主流用法，也是前后端分离的大趋势，有利于微服务的构建。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://yoursite.com/2019/02/18/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/02/18/哈希表/</id>
    <published>2019-02-18T06:26:30.000Z</published>
    <updated>2019-03-28T12:57:53.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在学习Java和Python的时候经常使用的一种数据结构，像HashMap和字典都是封装好的哈希表，特点是他是一种动态储存结构，储存格式为&lt;code&gt;key-value&lt;/code&gt;形式，支持&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;SEARCH&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt;等一系列操作，他们的底层都是由各个程序语言的编译器维护出来了一个符号表，其中每个元素的&lt;code&gt;key&lt;/code&gt;为任意字符串，与不同语言中现哈希表的实现的&lt;code&gt;key&lt;/code&gt;对应。虽然看起来没什么，但是哈希表是实现字典操作的一个非常有效的数据结构，最坏情况下的搜索时间也与链表相同，也就是说他的最坏运行时间是O(n)，然而实际上在合理假设的情况下，哈希表的查找时间甚至达到了O(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>mongodb安装</title>
    <link href="http://yoursite.com/2019/02/05/mongodb%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/02/05/mongodb安装/</id>
    <published>2019-02-05T12:45:35.000Z</published>
    <updated>2019-02-07T05:32:14.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mongodb安装&quot;&gt;&lt;a href=&quot;#mongodb安装&quot; class=&quot;headerlink&quot; title=&quot;mongodb安装&quot;&gt;&lt;/a&gt;mongodb安装&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;大年初一无聊，玩玩mongodb。&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;再知乎上经常听到大名鼎鼎的nosql类型数据库，相对于关系型数据库来说，这个东西部署很简单，储存方式为虚拟内存+持久化存储，总结起来一个字————快。nosql存起来是&lt;code&gt;key-value&lt;/code&gt;形式的，也支持集合和对象但是并不支持事务，也不能连表查询。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="nosql" scheme="http://yoursite.com/tags/nosql/"/>
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>基本数据结构</title>
    <link href="http://yoursite.com/2019/02/02/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/02/02/基本数据结构/</id>
    <published>2019-02-02T02:35:35.000Z</published>
    <updated>2019-04-01T12:28:35.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本数据结构&quot;&gt;&lt;a href=&quot;#基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;基本数据结构&quot;&gt;&lt;/a&gt;基本数据结构&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;虽然以前都学过也都用过，但是并没有具体总结过，这里权当是复习了，使用C++的面对对象方法重新实现一下这几个数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>递归分治</title>
    <link href="http://yoursite.com/2019/02/01/%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB/"/>
    <id>http://yoursite.com/2019/02/01/递归分治/</id>
    <published>2019-02-01T04:04:06.000Z</published>
    <updated>2020-02-20T13:04:23.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;递归分治&quot;&gt;&lt;a href=&quot;#递归分治&quot; class=&quot;headerlink&quot; title=&quot;递归分治&quot;&gt;&lt;/a&gt;递归分治&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在之前的归并排序中，使用了递归分治的方法，整个算法经历了三个过程。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;分解&lt;/strong&gt;：将原问题划分为一个个子问题，子问题与原问题形式一样，只是规模更小。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;求解&lt;/strong&gt;：递归的求出子问题。如果子问题规模足够小，停止递归，直接求解。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;合并&lt;/strong&gt;：将子问题的解组合成原问题的解。&lt;br&gt;&amp;emsp;&amp;emsp;当问题足够大时，需要递归求解，这就叫做&lt;strong&gt;递归情况&lt;/strong&gt;，当问题已经分解到足够小时并且不用再递归时，递归已经“触底”，进入&lt;strong&gt;基本情况&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>渐进记号</title>
    <link href="http://yoursite.com/2019/01/31/%E6%B8%90%E8%BF%9B%E8%AE%B0%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/01/31/渐进记号/</id>
    <published>2019-01-31T03:59:36.000Z</published>
    <updated>2019-02-01T03:53:31.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;渐进记号&quot;&gt;&lt;a href=&quot;#渐进记号&quot; class=&quot;headerlink&quot; title=&quot;渐进记号&quot;&gt;&lt;/a&gt;渐进记号&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在算法分析里面对算法运行时间以及效率问题分析时，当n的规模变得足够大时，我们引入了渐进分析记号$\Theta$来描述当输入规模无限大时，算法运行时间如何随输入规模变大而变大，现在来记录一下另外几种渐进记号约定，用来刻画算法某个其他其他方面的函数(空间与时间)。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法分析</title>
    <link href="http://yoursite.com/2019/01/24/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/01/24/算法分析/</id>
    <published>2019-01-24T03:28:51.000Z</published>
    <updated>2019-02-01T03:02:11.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法分析&quot;&gt;&lt;a href=&quot;#算法分析&quot; class=&quot;headerlink&quot; title=&quot;算法分析&quot;&gt;&lt;/a&gt;算法分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;The analysis of algorithm is the theoretical study of computer program performance and resource usage&lt;br&gt;算法分析是理论研究关于计算机程序性能和资源利用的研究。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-使用QueryDSL查询框架</title>
    <link href="http://yoursite.com/2019/01/22/SpringBoot-%E4%BD%BF%E7%94%A8QueryDSL%E6%9F%A5%E8%AF%A2%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/01/22/SpringBoot-使用QueryDSL查询框架/</id>
    <published>2019-01-22T05:38:06.000Z</published>
    <updated>2019-01-24T10:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SpringBoot-使用QueryDSL查询框架-基础&quot;&gt;&lt;a href=&quot;#SpringBoot-使用QueryDSL查询框架-基础&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot-使用QueryDSL查询框架(基础)&quot;&gt;&lt;/a&gt;SpringBoot-使用QueryDSL查询框架(基础)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;QueryDSL是一个通用的查询框架，框架的核心原则是创建安全类型的查询，开始QueryDSL仅支持Hibernate（HQL），在不断开源人士加入QueryDSL团队后，陆续发布了针对JPA，JDO，JDBC，Lucene，Hibernate Search，MangoDB，Collections 和RDF(Relational Data Format) Bean等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在使用SpringDataJPA的时候，内置的QueryByExampleExecutor对复杂查询来说显然不怎么好用，于是在这里引入一个便于我们进行复杂查询的框架————QueryDSL。这个框架可以完美的和SpringDataJPA进行融合，接下来主要说怎么用。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="SpringDataJPA" scheme="http://yoursite.com/tags/SpringDataJPA/"/>
    
      <category term="QueryDSL" scheme="http://yoursite.com/tags/QueryDSL/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-整合SpringDataJPA</title>
    <link href="http://yoursite.com/2019/01/21/SpringBoot-%E6%95%B4%E5%90%88SpringDataJPA/"/>
    <id>http://yoursite.com/2019/01/21/SpringBoot-整合SpringDataJPA/</id>
    <published>2019-01-21T02:29:23.000Z</published>
    <updated>2019-05-21T00:58:08.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot-整合SpringDataJPA&quot;&gt;&lt;a href=&quot;#SpringBoot-整合SpringDataJPA&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot-整合SpringDataJPA&quot;&gt;&lt;/a&gt;SpringBoot-整合SpringDataJPA&lt;/h1&gt;&lt;h3 id=&quot;1-简述&quot;&gt;&lt;a href=&quot;#1-简述&quot; class=&quot;headerlink&quot; title=&quot;1.简述&quot;&gt;&lt;/a&gt;1.简述&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;SpringDataJPA是Spring Data的一个子项目，默认底层是Hibernate，使用基于JPA的Repository,极大的减少对数据库访问的代码量，仅仅使用内部接口就可以完成简单的crud操作。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="SpringDataJPA" scheme="http://yoursite.com/tags/SpringDataJPA/"/>
    
  </entry>
  
</feed>
