<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法,">





  <link rel="alternate" href="/atom.xml" title="荒原曾是乐土的博客" type="application/atom+xml">






<meta name="description" content="排序算法 输入：一个n个数的序列 a1，a2……an输出输入序列的一个排列a1‘，a2‘……n‘，使得a1‘&amp;lt;=a2‘&amp;lt;=……&amp;lt;=an‘  &amp;emsp;&amp;emsp;简而言之，排序就是将一组对象按照某一种逻辑顺序重新排列的过程，这是一个很古老的算法，同时在各个领域都起到了非常重要的作用，所以在这里对排序算法做一次总结。">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法">
<meta property="og:url" content="http://yoursite.com/2019/06/18/排序算法/index.html">
<meta property="og:site_name" content="荒原曾是乐土的博客">
<meta property="og:description" content="排序算法 输入：一个n个数的序列 a1，a2……an输出输入序列的一个排列a1‘，a2‘……n‘，使得a1‘&amp;lt;=a2‘&amp;lt;=……&amp;lt;=an‘  &amp;emsp;&amp;emsp;简而言之，排序就是将一组对象按照某一种逻辑顺序重新排列的过程，这是一个很古老的算法，同时在各个领域都起到了非常重要的作用，所以在这里对排序算法做一次总结。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/BC6C13DE6B379FF9B55C7D3D45198522.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/D7055F187A69F277DD3254DDA6920507.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/9D0A8560CF46BCED54EE5DA2540078DF.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/B924EAB6512A8690BEBEFB4E3C638E6B.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/24573113EBD7598912D3E0979FB1030B.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/8411ADCEEC89B604DA60252010180027.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/91EE02E4A9162E256B16CBA7A047A81C.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/85307F210C7063A68332DFF10708F7F7.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/1024555-20161218194508761-468169540.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/1024555-20161218163120151-452283750.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/0028FBA6A4AF91D657B4EC7DE07C2E7D.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/11259EDCC2874623F242CCA82C454AC6.png">
<meta property="og:image" content="http://yoursite.com/2019/06/18/排序算法/BB8A0FE6AA7E3AED33492A0F234693B5.png">
<meta property="og:updated_time" content="2019-07-15T05:23:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序算法">
<meta name="twitter:description" content="排序算法 输入：一个n个数的序列 a1，a2……an输出输入序列的一个排列a1‘，a2‘……n‘，使得a1‘&amp;lt;=a2‘&amp;lt;=……&amp;lt;=an‘  &amp;emsp;&amp;emsp;简而言之，排序就是将一组对象按照某一种逻辑顺序重新排列的过程，这是一个很古老的算法，同时在各个领域都起到了非常重要的作用，所以在这里对排序算法做一次总结。">
<meta name="twitter:image" content="http://yoursite.com/2019/06/18/排序算法/BC6C13DE6B379FF9B55C7D3D45198522.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/18/排序算法/">





  <title>排序算法 | 荒原曾是乐土的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">荒原曾是乐土的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">没有银弹</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-rchives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            rchives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/排序算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="荒原曾是乐土">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="荒原曾是乐土的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">排序算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T22:21:33+08:00">
                2019-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
          
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><blockquote>
<p>输入：一个n个数的序列 a<sub>1</sub>，a<sub>2</sub>……a<sub>n</sub><br>输出输入序列的一个排列a<sub>1</sub><sup>‘</sup>，a<sub>2</sub><sup>‘</sup>……<sub>n</sub><sup>‘</sup>，使得a<sub>1</sub><sup>‘</sup>&lt;=a<sub>2</sub><sup>‘</sup>&lt;=……&lt;=a<sub>n</sub><sup>‘</sup></p>
</blockquote>
<p>&emsp;&emsp;简而言之，排序就是将一组对象按照某一种逻辑顺序重新排列的过程，这是一个很古老的算法，同时在各个领域都起到了非常重要的作用，所以在这里对排序算法做一次总结。<br><a id="more"></a></p>
<h2 id="排序算法与数据结构"><a href="#排序算法与数据结构" class="headerlink" title="排序算法与数据结构"></a>排序算法与数据结构</h2><p>&emsp;&emsp;在我们进行练习的时候，通常都是使用一个个的数值进行排序，实际上，在应用中，我们不可能只对一个数值进行排序，而是对一个<strong>记录</strong>进行排序，排序的依据可能是其中的某一个<strong>关键字</strong>，除<strong>关键字</strong>之外，<strong>记录</strong>还会有<strong>卫星数据</strong>，所以在排序的过程中，并不是只对那些<strong>关键字</strong>进行排序，<strong>卫星数据</strong>也是要一同进行存取的。所以，如果<strong>卫星数据</strong>过大，在排序过程中挪动数据是比较耗费资源的，这种情况下，重新排列<strong>记录</strong>的指针数组而不是<strong>记录</strong>本身是一个更好的选择。<br>&emsp;&emsp;正是这些细节上的选择，区分开了程序与算法之间的不同。算法只会描述一个方法，记录之中的卫星数据大小是不考虑的。所以我们在研究排序问题的时候，假定元素由数字组成，这样在概念上比较直接。但是具体情况之中，一些细节问题可能需要我们使用不同的数据结构来解决，这也是一种挑战。</p>
<h2 id="为何使用排序？"><a href="#为何使用排序？" class="headerlink" title="为何使用排序？"></a>为何使用排序？</h2><p>&emsp;&emsp;上面也说了，排序在各个领域都起到了非常重要的作用。而且这是一个在计算机领域中非常基础的问题。虽然排序算法在许多语言中都被内置来(甚至连C语言也内置了排序算法)，但是对于一个学习者的角度来讲，排序算法往往能够帮助我们有效的解决其他类似的问题。在跟多领域中，排序往往是第一个需要被解决的问题，而且排序算法多种多样，他们实现优雅高效，具有很深的研究价值。下面我会对我学过对一些排序算法进行总结，尽管插入排序与归并排序在算法分析那里已经总结过了，这里作为一个整体性对总结，我会再次总结。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>&emsp;&emsp;冒泡排序是最早c语言程序设计课上学习的一个排序，也是大部分人所接触到的第一个排序，因为非常简单。但是因为它的性能很差，所以很多算法书籍中只会一笔带过，甚至就是作为一个课后习题出现。<br>&emsp;&emsp;冒泡排序是交换排序一种，它的原理是<strong>比较相邻两个元素，第一个比第二个大，就进行交换，往后每一对相邻的元素都进行这样的操作，直到最后一个，最后一个就是最大的数，持续这个步骤，直到无法继续交换为止</strong>，正如同它的名字一样，最大的值是依次以冒气泡的的方式往上冒出来的。看一下具体的排序过程，以整型数组{84,83,88,87,61}举例(我用ppt画个图)。<br>&emsp;&emsp;首先看第一趟冒泡.<br><img src="/2019/06/18/排序算法/BC6C13DE6B379FF9B55C7D3D45198522.png" alt=""><br>&emsp;&emsp;第一趟结束以后，可以看见最大值88已经被移动到了最后，接着第二趟.<br><img src="/2019/06/18/排序算法/D7055F187A69F277DD3254DDA6920507.png" alt=""><br>&emsp;&emsp;第二趟之后，第二大的数字87被移动到了倒数第二个。在看第三趟。<br><img src="/2019/06/18/排序算法/9D0A8560CF46BCED54EE5DA2540078DF.png" alt=""><br>&emsp;&emsp;第三趟之后，第三大的数字84被移动到了倒数第三个。<br><img src="/2019/06/18/排序算法/B924EAB6512A8690BEBEFB4E3C638E6B.png" alt=""><br>&emsp;&emsp;经历了四趟之后，整个数组排序完毕。<br>&emsp;&emsp;看一下冒泡排序的复杂度，最好情况下，即待排数据本身就是正序的，只需要一趟即可完成排序，比较次数为n-1，元素移动次数为0(不需要进行交换)，此时拥有最好的时间复杂度，即O(n);<br>&emsp;&emsp;再看一下最坏的情况，最坏情况即是待排数据是逆序的，此时就需要进行n-1趟排序操作，每次要比较n-i(1 ≤ i ≤ N - 1)次,由于完全逆序，每次比较都需要进行交换，而且每次交换都要移动三次数据(两个数据交换需要三次移动)，那么我们的比较次数为 $\frac{N(N-1)}{2}$=O(N<sup>2</sup>)，移动次数为 $\frac{3N(N-1)}{2}$=O(N<sup>2</sup>)，他的最坏时间复杂度是O(N<sup>2</sup>)，因此，它的平均时间复杂度也是O(N<sup>2</sup>)。由于其中只有在交换过程中会用到一个单位辅助空间，所以其空间复杂度为O(1)。<br>&emsp;&emsp;冒泡排序是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以相同元素的前后顺序并没有改变，冒泡排序是一种稳定排序算法。下面贴上冒泡排序的C++实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*冒泡排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbsort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = length<span class="number">-1</span>;  j &gt; i;  j--)&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j]&lt;a[j<span class="number">-1</span>])&#123;</span><br><span class="line">				temp = a[j];</span><br><span class="line">				a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">				a[j - <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>&emsp;&emsp;这也是一个非常简单的排序算法，它的排序规则是这样的，<strong>首先找到数组中最小的元素，将它与数组中第一个元素的位置交换，然后再从剩下的元素中选取最小的元素，与数组的第二的元素交换。如此往复，直到整个数组有序</strong>，因为其不断在待排序元素中选择最大(小)者，所以起名叫<strong>选择排序</strong>。大致看一下排序过程，以数组{12，2，16，30，28，10，16，20，6，18}为例。<br><img src="/2019/06/18/排序算法/24573113EBD7598912D3E0979FB1030B.png" alt=""><br>&emsp;&emsp;这个排序很简单，每一趟排序只是在比较当前元素与目前已知的最小元素，每一次排序都会将一个元素放在最终位置，从上图也可以看出来，对角线上的每一个元素都代表一次交换，总交换次数为N，0～N-1的任意第i次交换都会伴随着一次交换与N-1-i次比较，所以总共会有N次交换与(N-1)+(N-1)…2+1=N(N-1)/2~N<sup>2</sup>/2次比较。<br>&emsp;&emsp;在上面对冒泡排序的分析中，提到了最好运行时间与最坏运行时间，但是选择排序有一个特点，它的<strong>运行时间与输入无关</strong>，每一遍扫描并不能为下一遍提供什么信息或者遍历，所以无论原始序列有序无序、正序逆序，他们用的时间都一样长！它并不会向其他算法一样依赖初始状态，这有时候是个好事，有时候也是个坏事，它的时间复杂度是O(N<sup>2</sup>)。<br>&emsp;&emsp;选择排序对数据移动可以说是最少的，每次交换都会改变两个数组元素，一共N次交换，并且交换次数与数组长度呈线性关系，这是一个其他算法都不具备的特征(大部分都是线性对数或者平方关系)，虽然选择排序和冒泡排序的时间复杂度在数量级上是一样的，都是两层循环。但是冒泡排序平均的换位操作比选择排序要多，所以内层循环中，选择排序只有O(N)而冒泡排序有O(N<sup>2</sup>/2)，所以综合来讲选择排序的时间效率要高于冒泡排序。下面贴出代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> swap = a[i];</span><br><span class="line">	a[i] = a[j];</span><br><span class="line">	a[j] = swap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*选择排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;<span class="comment">//将a[i]与a[i+1...length]的最小元素交换</span></span><br><span class="line">		<span class="keyword">int</span> min = i;<span class="comment">//最小元素索引</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">				min = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		exch(a, i, min);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>&emsp;&emsp;这个排序在算法分析中作为例子讲到过，现在再来说一遍。这个排序有点像在打牌的时候整理自己的手牌，我们会将未排序的牌插入到已经排好序的手牌之中，而且为了填补空缺，在牌移动前和移动后位置中间的所有牌会向后移动一位，插入排序算法的思路也是如此。<br>&emsp;&emsp;与选择排序一样，插入排序的索引左侧的元素的排列是有序的，但是在排序结束之前，那些元素的位置并不确定，中间随时可能移动，当索引达到另外一侧时，排序完毕。看一下插入排序的过程。<br><img src="/2019/06/18/排序算法/8411ADCEEC89B604DA60252010180027.png" alt=""><br>&emsp;&emsp;在这个N*N的轨迹表上很容易看出来交换和比较次数，最坏情况下是对角线一下所有元素都要移动位置(当前插入元素比所有一排序元素都要小),最好情况下根本不需要移动(当前插入元素比所有待排元素都大)，插入排序与选择排序不同，它的排序时间取决于初始元素顺序，比如一个有序数组的排序要比逆序或者乱序数组要快很多。<br>&emsp;&emsp;最坏情况下在对角线以下所有元素都要移动与被比较，所以总共N<sup>2</sup>/2次比较与N<sup>2</sup>/2移动，而平均情况下，每次排序需要移动与被比较的元素为对角线一下元素总数的二分之一，那么总共N<sup>2</sup>/4次比较与N<sup>2</sup>/4移动。当然，最好情况下，它只需要N次比较与0次交换。总体来说，它的时间复杂度也是O(N<sup>2</sup>)。<br>&emsp;&emsp;这种排序对于某种非随机数组特别有效，比如对一个有序数组来说，插入排序在发现其是有序之后，它的运行时间就会变成线性的。下面贴出实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> key, i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; length; j++) &#123;<span class="comment">//从第二个开始遍历，直到最后一个</span></span><br><span class="line">		key = a[j];<span class="comment">//标记当前需要插入的数</span></span><br><span class="line">		i = j - <span class="number">1</span>;<span class="comment">//i作为指针，遍历j之前的数</span></span><br><span class="line">		<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; a[i] &gt; key) &#123;</span><br><span class="line">			<span class="comment">//开始遍历，如果遍历到的数比key大，就把这个数向后移一位，知道循环完毕或者碰到比key小的数</span></span><br><span class="line">			a[i + <span class="number">1</span>] = a[i];</span><br><span class="line">			i = i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i + <span class="number">1</span>] = key;<span class="comment">//将key插入</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>&emsp;&emsp;在上面的插入排序中，如果原始序列非常大而且是乱序的话，插入排序的速度就会变得非常慢。在插入的过程中，元素只能与相邻的元素交换，于是只能一步一步的移动到最终位置，如果最小元素正好在序列的另一端，那么移动到另外一端就需要N-1次移动。为了加快这一进度，我们需要对插入排序进行改进，这也体现了我们研究初级排序算法的价值。我们让不相邻元素交换以达到局部排序，最后再让元素进行插入排序将局部有序数组排序，这种排序方法叫做<strong>希尔排序</strong>。<br>&emsp;&emsp;希尔排序的思想是使数组中任意间隔为h的元素有序，称为h有序数组，h有序数组就是h个独立的数组编织在一起形成的数组。从整体数组来看，数组中间每隔h个位置的元素的集合，就是h个独立数组中的一个数组。<br><img src="/2019/06/18/排序算法/91EE02E4A9162E256B16CBA7A047A81C.png" alt=""><br>&emsp;&emsp;对于任意h序列(不是h数组，这里指h的取值序列，最后一个元素是1)，在h很大的时候，我们可以将元素与其间隔非常远的元素进行交换，使得在h取得更小数字的时候排序方便。一般会选取一个初始的h值，N/3也好，N/5也好（N是数组长度)，然后每一次进行h数组进行插入排序之后就递减，一直到1。排序期间，希尔排序会对每一个h独立的子数组进行插入排序，由于子数组是相互独立的，我们只需要将原来插入排序中移动距离由1增加到h，所以希尔排序可以看作是插入排序使用不同增量过程的结果。当h递减到1时，希尔排序就变成了插入排序。<br>&emsp;&emsp;上面几个排序我们都分析了他们的性能，但是对于希尔排序而言，它的性能分析相当复杂，其子数组部分有序成都完全取决于递增序列的选择。而这个选择并不简单，它并非仅仅取决于h的选择，而且与其某些数学性质有关，直到现在也没有证明出来哪一种序列才是最好的选择。<br>&emsp;&emsp;但是事实证明，希尔排序在大型数组的排序中是绝对优于选择排序和插入排序的，并且数组越大，优势越大。只不过对于他性能的认证已经超出我们的范围，唯一能知道的是，它的运行时间达不到平方级别，最坏比较次数也只是与N<sup>3/2</sup>成正比。</p>
<blockquote>
<p>当一个“h有序”的数组按照增幅k排序后，它仍然是“h有序”的。</p>
</blockquote>
<p>&emsp;&emsp;希尔排序执行过程如下，h分别取5，3，1。相同颜色代表同一h子数组。<br><img src="/2019/06/18/排序算法/85307F210C7063A68332DFF10708F7F7.png" alt=""><br>&emsp;&emsp;代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> swap = a[i];</span><br><span class="line">	a[i] = a[j];</span><br><span class="line">	a[j] = swap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*希尔排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (h &lt; length/<span class="number">3</span>)&#123;</span><br><span class="line">		h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ( h&gt;=<span class="number">1</span> )&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; length; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i;  j &gt;= h&amp;&amp;(a[j]&lt;a[j-h]);  j-=h)&#123;</span><br><span class="line">				exch(a, j, j - h);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		h = h / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>&emsp;&emsp;首先对于数组A[1……n]</p>
<blockquote>
<p>1.如果n为1，那么数组就是排好序的。<br>2.递归的对A[1到n/2向上取整]的这一部分，以及A[n/2+1向上取整到n]这部分排序<br>3.把排好序的两个表归并</p>
</blockquote>
<p>归并过程如图所示<br><img src="/2019/06/18/排序算法/1024555-20161218194508761-468169540.png" alt=""><br>实质上就是将两个已排序好对的数组，也就是A[1..N/2]和A[N/2+1..n]，进行归并，得到一个排序好的数组，每一步都是固定的操作与数组长度无关，所以对于总数为n的输入，时间是$\Theta$(n)的。<br>&emsp;&emsp;对于这个递归，我们可以写出一个递推式。</p>
<blockquote>
<p>$$T(n) =\begin{cases}<br>Θ(1) &amp; （n=1） \<br>2T(n/2)+ Θ(n) &amp; （n&gt;1）<br>\end{cases}$$</p>
</blockquote>
<p><img src="/2019/06/18/排序算法/1024555-20161218163120151-452283750.png" alt=""><br>&emsp;&emsp;这是一个树状结构，树的末端时间只有$\Theta$(1)，而树的高度是lgn，叶的节点总数为n，完全扩展的递归树有lgn+1层，每层贡献总代价$\Theta$(n)，如果计算总数就是$\Theta$(n)lgn+$\Theta$(n)，根据渐进的思想，最后结果就是$\Theta$(nlgn)，考虑渐进，他比$\Theta$(n<sup>2</sup>)快,在数据足够大的情况下，归并排序将优于插入排序，差不多n大于30归并就更快了。<br>下面是对《算法导论》中归并排序的C++实现，该算法使用了自底向上归并，并且使用了辅助数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">204800</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> p,<span class="keyword">int</span> q,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=q-p+<span class="number">1</span>;<span class="comment">//左数组长度</span></span><br><span class="line">    <span class="keyword">int</span> n2=r-q;<span class="comment">//右数组长度</span></span><br><span class="line">    <span class="keyword">int</span> left[n1+<span class="number">1</span>],right[n2+<span class="number">1</span>];<span class="comment">//开辟新的左右数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i !=n1; ++i)&#123;</span><br><span class="line">        left[i]=arr[p+i];<span class="comment">//为左数组赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    left[n1]=N;<span class="comment">//左数组“哨兵”</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j!= n2; ++j)&#123;</span><br><span class="line">        right[j]=arr[q+j+<span class="number">1</span>];<span class="comment">//为右数组赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    right[n2]=N;<span class="comment">//右数组“哨兵”</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = p; k !=r+<span class="number">1</span>; ++k)<span class="comment">//将左右数组归并至原数组&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(left[i]&gt;right[j])&#123;</span><br><span class="line">            arr[k]=right[j];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[k]=left[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//分治法，将数组分割，将复杂问题化简为数个简单问题</span></span><br><span class="line">    <span class="keyword">if</span>(p&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> q=(p+r)/<span class="number">2</span>;<span class="comment">//数组分割标记，中间下标</span></span><br><span class="line">        MergeSort(arr,p,q);<span class="comment">//分割左边数组</span></span><br><span class="line">        MergeSort(arr,q+<span class="number">1</span>,r);<span class="comment">//分割右边数组</span></span><br><span class="line">        Merge(arr,p,q,r);<span class="comment">//进行归并排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>&emsp;&emsp;<strong>快速排序</strong>是使用最广泛的排序算法，甚至大部分语言内置的库中使用的排序算法默认使用的就是快速排序。原因很简单，一个是因为它的实现很简单，而且平均性能非常好，一般情况下比其他算法要快得多。快速排序是一种原址排序，而且在长度为n的数组所需的时间和nlgn成正比。<br>&emsp;&emsp;快速排序是基于分治思想的，所以它的算法过程也是经历三个阶段。</p>
<blockquote>
<p><strong>1.分解</strong>：数组A[p,q]被划分为左子数组A[p..s-1]与右子数组A[s+1..q]，使得A[p..s-1]的每一个元素都小于A[s]，使得A[s+1..q]中的每一个元素都大于A[s]，A[s]所在的位置就是它最终在的位置。<br><strong>2.解决</strong>：通过递归的调用快速排序，对子数组A[p..s-1]和A[s+1..q]继续分解，重复执行分解过程，直至不能分解。<br><strong>3.合并</strong>：由于我们使用的是原址排序，所以在递归执行到最底层的时候，数组A[p,q]就已经被排序完毕了，并不需要合并操作。</p>
</blockquote>
<p>&emsp;&emsp;快速排序最重要的就是<strong>数组划分</strong>的过程，这一过程实现了原址重排。<br>&emsp;&emsp;过程也比较简单，首先我们选择一个主元，一般为了方便我们都会选第一个或者最后一个，这个主元便是我们数组划分的依据，我们设这个主元为v，设这个数组的上界为hi，下界为lo。为了方便，在这里我们的v就随意的设成第一个元素即A[lo]，我们使用标记i、j，分别从A[lo+1]和A[hi]开始（也就是两端，不从A[lo]开始是因为A[lo+1]是主元），逐步从中间靠拢。如果出现A[i] &gt; v,i停止向后靠拢，出现A[j] &lt; v,j停止向前靠拢，二者同时停止时，就将A[i]与A[j]互换位置，然后继续向中间靠拢，重复上面的操作，直到i与j相遇，然后将v放在这个位置，这是就满足了主元前面都比主元小，主元后面都比主元大，同时主元也为更深层次的数组划分提供依据，而且这个数组被遍历了一次，所以一次划分的时间复杂度是$\Theta$(n) （n = hi - lo + 1）。下面是划分过程。</p>
<p><img src="/2019/06/18/排序算法/0028FBA6A4AF91D657B4EC7DE07C2E7D.png" alt=""><br>&emsp;&emsp;注意，这里只是提供一种快速排序的数组划分方法，这个方法并不惟一，不同教材上写的也不尽相同，但是划分思路是一样。</p>
<p>&emsp;&emsp;在性能方面，快速排序的运行时间主要取决于数组划分是否平衡，是否平衡划分又取决于用于划分的元素，即主元。如果划分平衡的话，它的性能相当于归并排序，如果不平衡的话，它的效率就接近于插入排序了。<br>&emsp;&emsp;如果是在最坏情况下划分的话，即一子数组被分到了n-1个元素，一个数组被分到了0个元素，这种划分是最不均衡的。那我们就假设每一次划分都会遇见这一种情况，划分操作的复杂度为$\Theta$(n)。一个数组为0时，递归会直接返回，所以 T(0) = $\Theta$(1)。我们可以得到算法的递归式。</p>
<blockquote>
<p>T(n) = T(n - 1) + T(0) + $\Theta$(n) = T(n - 1) + $\Theta$(n)</p>
</blockquote>
<p>&emsp;&emsp;我们将每一层的代价累加，就能得到一个算术级数，其结果是$\Theta$(n<sup>2</sup>)。所以在最坏情况下，快速排序的效率和插入排序一样，就算输入数组已经完全有序，它的效率还是$\Theta$(n<sup>2</sup>)，而这时候插入排序已经就是$\Theta$(n)了。</p>
<p>&emsp;&emsp;再看看最好的情况，最平衡的划分就是把主元去掉然后对半分了，两个子数组的大小都不会大于n/2。一个子数组规模为$\lfloor$n/2$\rfloor$，而另一个子数组的规模就是$\lceil$n/2$\rceil$-1.我们可以得到一个递归式。</p>
<blockquote>
<p>T(n) = 2T(n/2) + $\Theta$(n)</p>
</blockquote>
<p>&emsp;&emsp;根据主定理，这个递归式的解是T(n) = $\Theta$(nlgn)。这样的划分可以使渐进时间更快。<br>&emsp;&emsp;快速排序算法被广泛使用的原因就是它的平均运行时间总是接近于它的最好情况的。假设产生一个9:1的划分，那么它的递归式就是。</p>
<blockquote>
<p>T(n) = T(9n/10) + T(n/10) + cn<br>我们显示的写出$\Theta$(n)所隐含的常数c</p>
</blockquote>
<p>&emsp;&emsp;如果是一棵树的话，这棵树的每一层代价都是cn。这棵树在深度为log<sub>10</sub>n = $\Theta$(nlgn)地方就能达到递归边界，而我们的递归的终止是在深度为log<sub>10/9</sub>n = $\Theta$(lgn)的地方。在达到第一个递归边界与递归终止之前，每层代价至多为cn。所以说它的总代价就是O(nlgn)。即使是9:1这种非常不规则的划分，它的运行时间居然和最好运行时间是一样的。事实上，即便是99：1，它的时间复杂度还是这样。</p>
<blockquote>
<p>任何一种常数比例划分都会产生深度为$\Theta$(lgn)都递归树，每一层代价都是O(n)。所以只要划分是常数比例，它的运行时间总是O(nlgn)。</p>
</blockquote>
<p>&emsp;&emsp;下面给出快速排序的实现，这个实现是由E.W.Dijkstra（就是那个图论中求最短路径的Dijkstra算法的发明者）解出的三项切分的快速排序，我们在小于和大于的基础上引进一个等于，解决了重复排序的问题，使得其在重复元素很多的应用中更加快速。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> swap = a[i];</span><br><span class="line">	a[i] = a[j];</span><br><span class="line">	a[j] = swap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*三向切分快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>*a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hi &lt;= lo)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">	<span class="keyword">int</span> v = a[lo];</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= gt)&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; v) &#123;</span><br><span class="line">			exch(a, lt++, i++);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; v)&#123;</span><br><span class="line">			exch(a, i, gt++);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	quicksort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">	quicksort(a, gt+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>&emsp;&emsp;首先来说一下<strong>堆</strong>是个什么东西，它也叫二叉堆，一般用数组实现，从逻辑结构上讲类似一棵完全二叉树，每个节点对应数组中的元素，除了最后一层之外，这个树是完全充满的。在数组中，我们可以通过一些简单的计算来算出一棵树的父节点以及左右叶子结点。</p>
<blockquote>
<p>int parent(int i) {<br>    return i / 2;<br>}<br>int left(int i) {<br>    return 2 <em> i;<br>}<br>int right(int i) {<br>    return 2 </em> i + 1;<br>}</p>
</blockquote>
<p>&emsp;&emsp;二叉堆分两种，一种叫<strong>最大堆</strong>，一种叫<strong>最小堆</strong>，他们的共同点是都满足堆的性质，即是一个完全二叉树。最大堆中，对于某一个节点i来说，它的大小必须不能大于它的父节点。而在最小堆中，任意一个节点不能小于它的父节点。直观来讲，在层序上，从下往上呈现上升（下降）的趋势，根节点是最大（小）的元素。既然堆是一种完全二叉树，那么n个节点的完全二叉树的高度就是$\Theta$(log<sub>2</sub>n)，基本操作时间与高度成正比，所以时间复杂度也是O(log<sub>2</sub>n)。<br>&emsp;&emsp;由于在堆排序中可能会有元素变动之后，堆就不符合最大堆的性质，或者整个数组输入的时候就不符合最大堆的性质。这个时候我们需要让某些元素在堆中逐级下降，使其能够满足最大堆的性质，这个过程就是<strong>堆的维护</strong>。<strong>堆的维护</strong>是一个递归的过程，每次递归的操作，就是将父节点i与其左右节点相比较，如果i是最大的，那么这个子树必然满足最大堆的性质，如果最大的点不是i，那么i节点与那个最大的元素交换，递归完毕之后，就能够形成一个最大堆。这一过程中，它的时间代价有调整父节点与其左右关系节点的代价，是$\Theta$(1)。再算上时间代价每个孩子的子树大小至多为2n/3（底层恰好半满就是最坏情况）。我们可以得到一个递归式。</p>
<blockquote>
<p>T(n) = T(2n/3) + $\Theta$(1)</p>
</blockquote>
<p>&emsp;&emsp;使用主定理解一下，能得到T(n) = O(log<sub>2</sub>n)。所以说，对于一个堆的维护来说，它的时间复杂度与其树的高度有关。<br>&emsp;&emsp;接下来要执行建堆过程，数组元素从$\lfloor$n/2$\rfloor$+1到n都是叶子结点，而叶子结点所形成的堆只有一个元素，不需要调整，那么我们就需要对非叶子结点进行最大堆的调整。我们从$\lfloor$n/2$\rfloor$开始一直到1，逐个调用堆的维护算法，使其形成最大堆。由于过程复杂，时间复杂度的推导就不再写了，把无序数组构建为一个最大堆的时间是线行的，也就是O(n)。<br>&emsp;&emsp;在有了堆的维护和堆的调整之后，就可以进行堆排序算法了，它的本质是一种选择排序。首先将数组初始化为最大堆，这时候根节点就是最大的，然后将根节点与最后一个节点交换，此时最后位置这个节点就需要被排除出堆了，因为他目前已经到了它最终所在的位置（这一操作可以通过n-1来实现）。这个时候的堆可能已经不满足最大对的性质了，所以要进行一次调整，使其继续满足最大堆的特性。然后重复上面的操作，直到最后就剩一个节点。此时这个数组已经被排序了。这一过程非其实就是一个选择的过程，通过最大堆找到堆中最大的元素，将其挑出，然后再次调整为堆大堆，就能够挑出第二大的元素，直到最后就能将所有元素排序，下面是堆排序的过程，并没有排完，但是后面的过程是一样的。<br><img src="/2019/06/18/排序算法/11259EDCC2874623F242CCA82C454AC6.png" alt=""></p>
<p>&emsp;&emsp;堆排序过程中，每一次调用建堆的时间复杂度是O(n)，n-1次调用堆维护，每次时间为O(log<sub>2</sub>n)，所以对排序的时间复杂度为O(nlog<sub>2</sub>n)。下面是实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Maxheapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> largest;</span><br><span class="line">	<span class="keyword">int</span> l = left(i);<span class="comment">// 左子节点坐标</span></span><br><span class="line">	<span class="keyword">int</span> r = right(i);<span class="comment">// 右子节点坐标</span></span><br><span class="line">	<span class="keyword">if</span> (l&lt;length &amp;&amp; A[l]&gt;A[i]) &#123;<span class="comment">//用两个判断筛选当前节点与左右子节点的最大值</span></span><br><span class="line">		largest = l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		largest = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (r&lt;length &amp;&amp; A[r]&gt;A[largest]) &#123;</span><br><span class="line">		largest = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (largest != i) &#123;<span class="comment">//当前节点与除本身以外的最大值交换</span></span><br><span class="line">		<span class="keyword">int</span> k = A[i];</span><br><span class="line">		A[i] = A[largest];</span><br><span class="line">		A[largest] = k;</span><br><span class="line">		Maxheapify(A, largest, length);<span class="comment">//继续向下重复此操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildmaxheap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;<span class="comment">//建立最大堆</span></span><br><span class="line">	<span class="keyword">int</span> length = A.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">		Maxheapify(A, i, length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*堆排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">	buildmaxheap(A);</span><br><span class="line">	<span class="keyword">int</span> length = A.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">int</span> k = A[i];</span><br><span class="line">		A[i] = A[<span class="number">1</span>];</span><br><span class="line">		A[<span class="number">1</span>] = k;</span><br><span class="line">		length -= <span class="number">1</span>;</span><br><span class="line">		Maxheapify(A, <span class="number">1</span>, length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>&emsp;&emsp;这是一种原来在卡片机上的一种算法，这种算法是按照每一位进行排序的，每一位的取值范围就是0-9这10个数字，每一个数字都代表一个容器。如果按照常规想法都话，一般从在高位开始排序，先按照最高位将数字插入0-9之间的容器中，然后将每个容器中的数据按照第二位再进行这样的排序，这是一个递归操作，直到最后。但是这么做的话一次只能排一个容器里的数据，当一个容器在排序的时候，其他容器都是未使用状态，多出来了许多不必要的临时储存空间，所以这种方式在很久以前内存紧张的时候并不是一个好的算法。<br>&emsp;&emsp;而基数排序则是选择<strong>从最低有效位开始进行排序</strong>，然后合并到一起。从第一位开始，所有第一位是0的数字排在所有第一位是1的数字之前，所有第一位是1的数字排在所有第一位是2的数字之前……然后对第二位进行重复操作，直到最高位，过程如图所示。<br><img src="/2019/06/18/排序算法/BB8A0FE6AA7E3AED33492A0F234693B5.png" alt=""><br>&emsp;&emsp;基数排序的算法就是这么直观，但是它的算法效率又是怎样的呢？</p>
<blockquote>
<p>给定n个d位数，其中每一个数位有k个取值，如果基数排序使用的稳定排序方法耗时$\Theta$(n+k)，那么他就可以在$\Theta$(d(n+k))时间内排好序。</p>
</blockquote>
<p>&emsp;&emsp;当每一位数字都在0到k-1之间，并且这个k不太大时，可以使用计数排序（不想在写这个计数排序了，这是一个区间范围内的整数排序，它的时间代价是$\Theta$(n+k)，十进制的基数排序中正好k就等于10，很适合采用计数排序对每一位进行排序。对于n个d位数字来说，每一轮排序耗费$\Theta$(n+k)，一共有d轮，所以基数排序总排序时间为$\Theta$(d(n+k))。</p>
<blockquote>
<p>对于给定n个b位数的和任何正整数r&lt;=b，如果基数排序使用的稳定排序算法对数据取值区间是0到k到输入进行排序耗时$\Theta$(n+k)，那么他就可以在$\Theta$((b/r)(n+2<sup>r</sup>))将这些数排好序。</p>
</blockquote>
<p>&emsp;&emsp;证明就不写了，脑壳疼……<br>&emsp;&emsp;至于这个选择用不用，我觉得还是别用，它的运行实现可能看上去比其他排序好一些，但是在渐进记号后面的常数因子却大的多，并且他没有快速排序那样可以有效使用硬件缓存，而且他也不是原址排序。具体实现如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基数排序</span></span><br><span class="line"><span class="comment">Input:</span></span><br><span class="line"><span class="comment">    数组A[l,h]；</span></span><br><span class="line"><span class="comment">    数组中最大元素的位数d，例如最大数为999，则d为3；</span></span><br><span class="line"><span class="comment">    进制数k，如果是10进制数，k为10；</span></span><br><span class="line"><span class="comment">Output:排序好的数组；</span></span><br><span class="line"><span class="comment">Others：对数字1234来说，预定第0位为4，第1位为3，依次类推；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> d, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == A || l &gt; h)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> size = h - l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>* counts = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//辅助数据	</span></span><br><span class="line">	<span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[size];<span class="comment">//用于存储重新排序的数组</span></span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">int</span> pval = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//依次处理不同的位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">		<span class="comment">//counts数组清零</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">			counts[j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= h; j++) &#123;</span><br><span class="line">			index = (<span class="keyword">int</span>)(A[j] / pval) % k;</span><br><span class="line">			counts[index]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//计算累加频数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++)</span><br><span class="line">			counts[j] = counts[j] + counts[j - <span class="number">1</span>];</span><br><span class="line">		<span class="comment">//使用倒数第i+1位数对A进行排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = h; j &gt;= l; j--) &#123;</span><br><span class="line">			index = (<span class="keyword">int</span>)(A[j] / pval) % k;</span><br><span class="line">			temp[counts[index] - <span class="number">1</span>] = A[j];</span><br><span class="line">			counts[index]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将按第i为数排序后的结果保存回数组A中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">			A[j + l] = temp[j];</span><br><span class="line">		<span class="comment">//更新pval</span></span><br><span class="line">		pval = pval * k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] counts;</span><br><span class="line">	<span class="keyword">delete</span>[] temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h2><p>&emsp;&emsp;这八种排序算法具体该选择哪一种，很大程度上取决于实际应用场景。下面用一张表来总结以上九种（快速排序分为普通的和三向切分的）排序算法。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th style="text-align:center">是否稳定</th>
<th style="text-align:right">是否为原址排序</th>
<th style="text-align:right">时间复杂度</th>
<th style="text-align:right">空间复杂度</th>
<th style="text-align:right">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td style="text-align:center">否</td>
<td style="text-align:right">是</td>
<td style="text-align:right">N<sup>2</sup></td>
<td style="text-align:right">1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>插入排序</td>
<td style="text-align:center">是</td>
<td style="text-align:right">是</td>
<td style="text-align:right">介于N和N<sup>2</sup>之间</td>
<td style="text-align:right">1</td>
<td style="text-align:right">与元素初始状态有关</td>
</tr>
<tr>
<td>希尔排序</td>
<td style="text-align:center">否</td>
<td style="text-align:right">是</td>
<td style="text-align:right">近似于Nlog<sub>2</sub>N和N<sup>6/5</sup></td>
<td style="text-align:right">1</td>
<td style="text-align:right">目前没有证出来</td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:center">否</td>
<td style="text-align:right">是</td>
<td style="text-align:right">Nlog<sub>2</sub>N</td>
<td style="text-align:right">log<sub>2</sub>N</td>
<td style="text-align:right">有大概率取得最好运行状态</td>
</tr>
<tr>
<td>三向切分快速排序</td>
<td style="text-align:center">否</td>
<td style="text-align:right">是</td>
<td style="text-align:right">介于N和Nlog<sub>2</sub>N之间</td>
<td style="text-align:right">log<sub>2</sub>N</td>
<td style="text-align:right">同时取决于概率和元素分布</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
<td style="text-align:right">Nlog<sub>2</sub>N</td>
<td style="text-align:right">N</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">否</td>
<td style="text-align:right">是</td>
<td style="text-align:right">Nlog<sub>2</sub>N</td>
<td style="text-align:right">1</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:center">是</td>
<td style="text-align:right">否</td>
<td style="text-align:right">d(N+k)</td>
<td style="text-align:right">(N+k)</td>
<td style="text-align:right">受隐藏常数因子影响太大</td>
</tr>
</tbody>
</table>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/22/禹州实训-宠物医院-后端/" rel="next" title="禹州实训-宠物医院-后端">
                <i class="fa fa-chevron-left"></i> 禹州实训-宠物医院-后端
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/15/机器学习-单变量线性回归/" rel="prev" title="机器学习-单变量线性回归">
                机器学习-单变量线性回归 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/timg.jpeg" alt="荒原曾是乐土">
            
              <p class="site-author-name" itemprop="name">荒原曾是乐土</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#排序算法"><span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法与数据结构"><span class="nav-text">排序算法与数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为何使用排序？"><span class="nav-text">为何使用排序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序"><span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序"><span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序"><span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序"><span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序"><span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法比较"><span class="nav-text">算法比较</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">荒原曾是乐土</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
<!--社会主义核心价值观-->
<script type="text/javascript" src="/js/src/click.js"></script>
